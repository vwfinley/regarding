\section{Solution B: Customize an Existing LaTeX Container Image}

For most documents and projects, finding an available LaTeX container image is a good strategy.

Maybe the image was written by a colleague, or maybe by some unknown external developer.
Perhaps the image has been published to: Docker Hub, GitHub registry, or maybe a private corporate registry.

In any case you will want to find an image that provides substantial functionality.
The more completely an image compiles features from your source files into a finished document, the less work you'll need to do.

Inevitably your selected image will be incomplete.
Some packages will be missing.
You will probably encounter errors that say something like \verb|LaTeX Error: File `gensymb.sty' not found|.
So, you will want to customize the container image to add any missing .sty package files.

\subsection{Image Customization}
Customization of the container image will resemble the iterative process shown in Figure \ref{fig:fig1}.
As you write your document, you will use the container to generate an output file.
You will then extend the container as needed until your output file is fully typeset as desired.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
  \node [minimum width=1.25cm,draw,circle] (a) at (0,0) {\scriptsize Pull};
  \node [minimum width=1.25cm,draw,circle] (b) at ($(a)+(1.75,0)$) {\scriptsize Use};
  \node [minimum width=1.25cm,draw,circle] (c) at ($(b)+(1.75,0)$) {\scriptsize Extend};
  \node [minimum width=1.25cm,draw,circle] (d) at ($(c)+(1.75,0)$) {\scriptsize Build};
  \node [minimum width=1.25cm,draw,circle] (e) at ($(d)+(1.75,0)$) {\scriptsize Push};

  \draw[-{Latex[scale=1.0]}] (a) -- (b);
  \draw[-{Latex[scale=1.0]}] (b) -- (c);
  \draw[-{Latex[scale=1.0]}] (c) -- (d);
  \draw[dashed, -{Latex[scale=1.0]}] (d) -- (e);
  \draw[dashed, -{Latex[scale=1.0]}] (e) to[out=135,in=45] (a);
  \draw[-{Latex[scale=1.0]}] (d) to[out=135,in=45] (b);
\end{tikzpicture}
\caption{\\Solution B Customization Workflow}
\label{fig:fig1}
\end{figure}

When you are satisfied with the resulting document file, you can optionally publish the container image to a registry with a Docker push command.

\subsection{Extending and Customization}
As an example, let's take a prebuilt LaTeX container image and customize it until it is suitable for typesetting this article you are now reading.

Glancing at Listing \ref{lst:dockerfile1} below you will see the LaTeX container image was written by a GitHub user named jmuchovej.
The image is uploaded to the GHCR (GitHub container registry).  
The container image can be found at \url{https://github.com/jmuchovej/devcontainers/pkgs/container/devcontainers%2Flatex}
Furthermore you can locate the image's source code at \url{https://github.com/jmuchovej/devcontainers/tree/main/images/src/latex}

\lstnewenvironment{code}[1][]
{
 \lstset{
 basicstyle=\ttfamily\scriptsize,
 columns=fullflexible,
 captionpos=b,
 #1
 }}{}


\begin{mdframed}[backgroundcolor=black!20,leftmargin=0.0cm,skipabove=0.4cm,hidealllines=true,
  innerleftmargin=0.1cm,innerrightmargin=0.1cm,innertopmargin=0.15cm,innerbottommargin=-1.4cm]
\begin{code}[caption={\\Image Customization Example}, label=lst:dockerfile1]
#-----------
# Dockerfile
#-----------
FROM ghcr.io/jmuchovej \
  /devcontainers/latex:2025

USER root

RUN <<EOF
    tlmgr update --self

    tlmgr install \
        pgf booktabs breqn caption \
        ec fc gensymb lastpage \
        makecell mathtools multirow \
        paralist parskip pgf sectsty \
        subfig tex4ht tocbibind 
        
    mktexpk --mfmode / --bdpi 600 \
      --mag 1+0/600 --dpi 600 tcrm1095
    mktexpk --mfmode / --bdpi 600 \
      --mag 1+0/600 --dpi 600 tcrm0900
    mktexpk --mfmode / --bdpi 600 \
      --mag 1+0/600 --dpi 600 tcrm0600
    mktexpk --mfmode / --bdpi 600 \
      --mag 1+0/600 --dpi 600 tcrm0800
EOF

USER vscode
\end{code}
\end{mdframed}

The package manger for the TexLive LaTeX distribution is named ``tlmgr'' (short for TexLive Manager) and it already resides inside the container.
We want to install some TexLive packages so that we can extend the functionality of the container.
In the listing you will see the tlmgr install command is called with a list of desired packages.
The list spans multiple lines that are separated with a backslash.

When the container is used to generate a .pdf file from .tex files, the latex process emits errors regarding missing fonts.
The way to avoid the errors is to create the missing fonts by calling mktexpk for each missing font. 

\subsection{Building}
A new container image can be generated by calling the Docker build command in the directory with the Dockerfile.
Be sure to give the image a meaningful tag with the -t option.

\begin{mdframed}[backgroundcolor=black!20,leftmargin=0.0cm,skipabove=0.4cm,hidealllines=true,
  innerleftmargin=0.1cm,innerrightmargin=0.1cm,innertopmargin=0.15cm,innerbottommargin=-1.4cm]
\begin{code}[caption={\\Script to Build Image}, label=lst:buildImage]
#!/bin/bash

#--------------
# buildImage.sh
#--------------
docker build --no-cache -t mytexliveimage:latest .
docker images
\end{code}
\end{mdframed}

As shown in listing \ref{lst:buildImage} you can capture the build command in a script file named build.sh and make it executable with a chmod 755 build.sh command. 
Now call ./scriptImage.sh on the commandline to build the image.
The image will be listed in the local Docker repository when the script completes. 

\subsection{Using Image from Host}
Let's use the image we just created to generate a .pdf document from a LaTeX source file.
We will put the command to generate the image into a shell script file named buildDocument.sh as shown in Listing \ref{lst:buildDocBasic}.

The script will generate a pdf file from a source LaTeX file named ``main.tex'', but it can be named anything you want.
You will want to run the buildDocument.sh script from the directory holding your main.tex file.


\begin{mdframed}[backgroundcolor=black!20,leftmargin=0.0cm,skipabove=0.4cm,hidealllines=true,
  innerleftmargin=0.1cm,innerrightmargin=0.1cm,innertopmargin=0.15cm,innerbottommargin=-1.4cm]
\begin{code}[caption={\\Script to Build PDF Document}, label=lst:buildDocBasic]
#!/bin/bash

#-----------------
# buildDocument.sh
#-----------------
docker run \
  --rm \
  -it \
  -v $(pwd):/workspace \
  mytexliveimage:latest \
  latex \
  -output-format=pdf \
  -output-directory=. \
  main.tex
\end{code}
\end{mdframed}

Notice how the the listing calls the Docker run command with the -v option?
This causes the current working directory with main.tex to be mapped into the running container.
Since the directory is mapped, main.tex will be visible inside the running container.

The container will run the application named ``latex'' to build the main.tex file.
Options -output-format=pdf and -output-directory for the ``latex'' application will write a pdf file in the current directory.


\subsection{Using Image as Developer Container}
When developing and troubleshooting your LaTeX container image, it may be helpful to work inside the container to resolve missing TexLive packages or other problems.
If you plan to work inside your container, consider choosing a base image that is a suitable ``developer container'' image.

Some base images are optimized to integrate with the VSCode Dev Container extension.
These optimized developer container images will give you a better VSCode development experience with less hassle. 
If you plan to run your LaTeX container as a developer container it is worth checking your container's base image.

Most developer containers should derive from official developer base images.
You can find them at \url{https://mcr.microsoft.com} if you search for ``development''.
For convenience, some development containers are already configured for specific languages such as: c++, java and python.
However we are interested in the plain vanilla base containers found at \url{https://mcr.microsoft.com/en-us/artifact/mar/devcontainers/base/tags}

You'll notice our latex image in Listing \ref{lst:dockerfile1} derives from the ghcr.io/jmuchovej/devcontainers/latex:2025 container image.
By looking at the source code at \url{https://github.com/jmuchovej/devcontainers/blob/main/images/src/latex/Dockerfile} we see that image is derived from the mcr.microsoft.com/devcontainers/base:noble developer container image.

Three different strategies can help you run your container as a developer container.
Each has its own benefits and drawbacks.

For more details about developer containers refer to \url{https://code.visualstudio.com/docs/devcontainers/containers}

\subsubsection{Run Developer Container From commandline}
Assuming you've previously built your container image as shown in Listing \ref{lst:buildImage} you can run it as a developer container.

Simply run Docker with the container name from the directory containing your code as shown below.
You will want to have Docker statup with the Bash shell as shown below in Listing \ref{lst:runDevContainer}.

\begin{mdframed}[backgroundcolor=black!20,leftmargin=0.0cm,skipabove=0.4cm,hidealllines=true,
  innerleftmargin=0.1cm,innerrightmargin=0.1cm,innertopmargin=0.15cm,innerbottommargin=-1.4cm]
\begin{code}[caption={\\Going Inside a Dev Container}, label=lst:runDevContainer]
#!/bin/bash

#-------------------
# runDevContainer.sh
#-------------------
docker run \
  --rm \
  -it \
  -v $(pwd):/workspace \
  mytexliveimage:latest \
  bash
\end{code}
\end{mdframed}

Once inside the developer container you can build your LaTeX document by running the script in Listing \ref{lst:buildDocument} below.

\begin{mdframed}[backgroundcolor=black!20,leftmargin=0.0cm,skipabove=0.4cm,hidealllines=true,
  innerleftmargin=0.1cm,innerrightmargin=0.1cm,innertopmargin=0.15cm,innerbottommargin=-1.4cm]
\begin{code}[caption={\\Building PDF Inside Dev Container}, label=lst:buildDocument]
#!/bin/bash

#-------------------
# buildDocument.sh
#-------------------
latex \
-output-format=pdf \
-output-directory=. \
main.tex
\end{code}
\end{mdframed}


\subsubsection{Run Developer Container as Dockerfile from VSCode}
A quick dirty way to run inside a developer container is to directly reference the container image Dockerfile from a VSCode devcontainer.json file.
The Dockerfile, similar to Listing \ref{lst:dockerfile1}, should be in the root directory of your document project.

Now create a file named ``devcontainer.json'' and place it in a hidden directory named ``.devcontainer''.
The devcontainer.json should reference the Dockerfile in the build section of the ``devcontainer.json'' file as shown in Listing \ref{lst:runDevContainerAsDockerfile}.

\begin{mdframed}[backgroundcolor=black!20,leftmargin=0.0cm,skipabove=0.4cm,hidealllines=true,
  innerleftmargin=0.1cm,innerrightmargin=0.1cm,innertopmargin=0.15cm,innerbottommargin=-1.4cm]
\begin{code}[caption={\\Run From VSCode As Dockerfile}, label=lst:runDevContainerAsDockerfile]
#--------------------------------
# .devcontainer/devcontainer.json
#--------------------------------
{
  "name": "LaTeX",

  ...
  ...
  ...

  "build": {
    "dockerfile": "../Dockerfile"
  }
}
\end{code}
\end{mdframed}

The next time you start VSCode in the root of your LaTeX document project, you should be prompted if you want to open VSCode in the developer container.
You will see a prompt that says ``Folder contains a Dev Container configuration file. Reopen folder to develop in a container''.
Click the Blue button to ``Reopen in container''.

Once the developer container's Bash shell prompt appears run the script in Listing \ref{lst:buildDocument} to build your document.

A disadvantage to running a developer container this way is that VSCode will attempt to rebuild the Developer container every time VSCde runs.
However, though annoying, you can tell VSCode to use the previously built image.

\subsubsection{Developer Container as Image from VSCode}

If you previously build an image from Listing \ref{lst:buildImage} starting the container from VSCde is relatively easy.
Simply create a developer file named .devcontainer/devcontainer.json as shown in Listing \ref{lst:runDevContainerFromImage}.

\begin{mdframed}[backgroundcolor=black!20,leftmargin=0.0cm,skipabove=0.4cm,hidealllines=true,
  innerleftmargin=0.1cm,innerrightmargin=0.1cm,innertopmargin=0.15cm,innerbottommargin=-1.4cm]
\begin{code}[caption={\\Running from Image}, label=lst:runDevContainerFromImage]
#--------------------------------
# .devcontainer/devcontainer.json
#--------------------------------
{
  "name": "LaTeX",

  ...
  ...
  ...
 
  "image": "mytexliveimage:latest"
}
\end{code}
\end{mdframed}

The next time you start VSCode in the root of you document project, VSCode will ask if you want to reopen your project in the developer container.
Once open run the script in Listing \ref{lst:buildDocument} to build your document.

This method of running as a Developer is advantageous if your image has everything your document needs, but tedious otherwise.
While your are testing and building your container image, you will need to rebuild and run the image after each iteration.
Wait until your container image is more or less complete before using this method.