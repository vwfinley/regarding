\section{Solution C: Scratchbuilding from a Base Image}

Rather than depending upon container images that have been populated by others, a better solution is to populate your own image from a base image.

The advantage to this solution is you have total control over the contents and configuration of the image.
You don't have to troubleshoot configurations some previous author may have forgotten to document.

Also, once you know how to scratchbuild from base images, you can deploy almost any application to a container, including your own code projects.

The workflow for building images from a base image is shown in Figure \ref{fig:fig2}.
You will notice it is similar but not the same as the Solution B workflow from Figure \ref{fig:fig1}.
Why is this?
Well, since we are starting with a empty base container we will first need to populate it before testing by generating a PDF document.
Usually, several attempts will be required to get the image to build correctly.
Inevitably packages or configurations will be missing and you'll need to iterate through the cycle in Figure \ref{fig:fig2}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
  \node [minimum width=1.25cm,draw,circle] (a) at (0,0) {\scriptsize Pull};
  \node [minimum width=1.25cm,draw,circle] (b) at ($(a)+(1.75,0)$) {\scriptsize Extend};
  \node [minimum width=1.25cm,draw,circle] (c) at ($(b)+(1.75,0)$) {\scriptsize Build};
  \node [minimum width=1.25cm,draw,circle] (d) at ($(c)+(1.75,0)$) {\scriptsize Test};
  \node [minimum width=1.25cm,draw,circle] (e) at ($(d)+(1.75,0)$) {\scriptsize Push};

  \draw[-{Latex[scale=1.0]}] (a) -- (b);
  \draw[-{Latex[scale=1.0]}] (b) -- (c);
  \draw[-{Latex[scale=1.0]}] (c) -- (d);
  \draw[-{Latex[scale=1.0]}] (d) -- (e);
  \draw[-{Latex[scale=1.0]}] (e) to[out=135,in=45] (a);
  \draw[-{Latex[scale=1.0]}] (d) to[out=135,in=45] (b);
\end{tikzpicture}
\caption{\\Solution C Customization Workflow}
\label{fig:fig2}
\end{figure}

\subsection{Strategy}
The strategy for scratchbuilding our own LaTeX container image is:
\begin{itemize}
\item Pull a suitable base devcontainer image
\item Install the TexLive LaTeX distribution into the image. 
\item Add any missing needed packages
\item Fix any warnings/errors (mktexpk for generating missing fonts)
\item Use container for a project
\end{itemize}

Furthermore, we will be rebuilding the container image frequently during development and maintenance.
It would be nice to automate the build process.
Therefore, this is a great opportunity to learn about GitHub pipelines, actions and runners.

We would like to break the problem up into two parts.
The first part is to create an image only with a basic TexLive distribution.
This second part is to add any extra packages to the first image and create another image.

The idea here is our basic TexLive image can be reused to create other images that are customized as necessary for specific document projects.
If we pollute the basic TexLive image with unnecessary packages it won't suit most document projects anyway.
The image would need to be customized to accommodate most document projects, so why not just start with a simple image and a clear way to customize it as needed.

The code that follows is checked in at \url{https://github.com/vwfinley/texlive} and \url{https://github.com/vwfinley/texlive_dev}.

\subsection{Select Base Image}

First let's choose a suitable base image.
The mcr.microsoft.com/devcontainers/base:dev-debian-12 image is a friendly plain vanilla developer container image.
You will find it listed here: \url{The base image https://mcr.microsoft.com/en-us/artifact/mar/devcontainers/base/tag/dev-debian-12}
Sure we could find some non-developer image, but a developer image will play nice with VSCode.
If you are setting up a production environment, where hundreds of documents will be built and published, then you might consider a slim bare-bones non-developer image.

\subsection{Install TexLive}

In Listing \ref{lst:scratchbuildTexlive} we see a Dockerfile that installs the TexLive 2025 LaTeX distribution into a Debian 12 developer container.
It makes heavy use of ARG and ENV variables to help cut down on the clutter and make it easier to read.

\begin{mdframed}[backgroundcolor=black!20,leftmargin=0.0cm,skipabove=0.4cm,hidealllines=true,
  innerleftmargin=0.1cm,innerrightmargin=0.1cm,innertopmargin=0.15cm,innerbottommargin=-1.4cm]
\begin{code}[caption={\\Dockerfile for TexLive Core Image}, label=lst:scratchbuildTexlive]
#-----------
# Dockerfile
#-----------
ARG SRC_IMG=mcr.microsoft.com/devcontainers/base
ARG TAG=dev-debian-12

FROM ${SRC_IMG}:${TAG}

ARG DEST=https://github.com/vwfinley/texlive
ARG MIRROR=https://mirror.ctan.org
ARG FILE=systems/texlive/tlnet/install-tl-unx.tar.gz
ARG VER=2025
ARG SCHEME=small
ARG DIR=/usr/local/texlive/${VER}/bin/x86_64-linux

ENV PATH="$PATH:${DIR}"

LABEL org.opencontainers.image.source ${DEST}

RUN apt-get update

WORKDIR /tmp 

RUN <<EOF
  wget ${MIRROR}/${FILE}
  zcat < install-tl-unx.tar.gz | tar xf -
  cd install-tl-*
  perl ./install-tl --scheme=${SCHEME} \
    --no-interaction --no-doc-install \
    --no-src-install
  tlmgr update --all
  cd ..
  rm -r install*
EOF

WORKDIR /workspace 

USER vscode
\end{code}
\end{mdframed}

Most of the instructions in the Dockerfile are run as the root user.
The important parts of this Dockerfile are the FROM and RUN statements.

The FROM statement simply pulls the Debian 12 developer image from Microsoft's container registry.

The RUN statements are a little more interesting.
The first RUN statement simply calls ``apt-get'', which is Debian's package manager to update any installed packages.
The second RUN statement is based upon the non-interactive commandline QuickInstall instructions for Unix.
See the ``tl;dr: Unix(ish)'' section at \url{https://tug.org/texlive/quickinstall.html}

Looking at the second RUN statement we notice wget is used to download the TexLive install-tl-unx tarball from a mirror server.
Then zcat and tar are called to unpack the tarball.
After changing directory to where the tarball was unpacked, perl is called with the install-tl installer script.
The script is run with some options:
\begin{itemize}
\item The scheme option is set to small, this will install the core TexLive distribution plus some essential packages.
\item The no-interaction option causes the installer to run without asking a human for any information.
\item The no-doc-install option will save space by not installing any documentation files.
\item The no-src-install option will save space by not installing any source code for packages.
\end{itemize}
Then tlmgr is run to install any updates to TexLive.
Afterwards the install directory is removed to save space.

The LABEL statement is worth noting.
It sets the label attribute named ``org.opencontainers.image.source''.
This label attribute is metadata that gets displayed in GitHub.

The last two lines set the working directory and default user for the container.

\subsection{Building the TexLib Core image}
Now that we've explained the contents of the Dockerfile in Listing \ref{lst:scratchbuildTexlive}, let's actually create the core TexLive image locally.
Assuming Docker is installed on your host development system, this is easily accomplished at the command line.

Simply change directories to where the Dockerfile lives and enter:

\begin{mdframed}[backgroundcolor=black!20,leftmargin=0.0cm,skipabove=0.4cm,hidealllines=true,
  innerleftmargin=0.1cm,innerrightmargin=0.1cm,innertopmargin=0.15cm,innerbottommargin=-1.4cm]
\begin{code}[caption={\\Building the TexLive Core Image}, label=lst:buildingCore]
docker build -t my_texlive_core .

docker images
\end{code}
\end{mdframed}

After a few minutes building, your image will appear in Docker's image list.

\subsection{Testing}

After buiding your TexLive Core image you will want to verify that TexLive works.
Let's assume you have a sample LaTeX document you want to create, and the source of the document is contained in a file named main.tex.
You can use your my_texlive_core container to transform the main.tex file into a .pdf file in two different ways.

The resulting .pdf file will be written to the same directory where main.tex lives.
If your main.tex file is complex or references other .tex files, you should expect the latex program to display errors.
Don't worry, the errors are probably referring to some missing features.
You could add the tlmgr command in the Dockerfile from Listing \ref{lst:scratchbuildTexlive} to install the features.
However, as we'll see later in the article, there is a better way to add the missing features.

\subsubsection{Build document from inside container}
On the commandline of your host development system:
\begin{itemize}
  \item Change directories to where the main.tex file lives.
  \item Start your Core TexLive container with current directory mounted.
  \item Run the TexLive latex program with the pdf option. 
\end{itemize}

Your session should similar to Listings \ref{lst:runDevContainer} and \ref{lst:buildDocument}.

\subsubsection{Build document from host (from outside the container)}

This method of building your test document avoids the need to enter the container directly.
Building the main.tex document from the outside allows you to create a build script that runs on your development host system.
In other words, it encourages automation.

On the commandline of your host development system, follow Listing \ref{lst:buildDocBasic} and change names and details as needed.
Afterwards the resulting .pdf should appear in the current directory.