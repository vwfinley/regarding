\section{Solution}
You are probably working on either a laptop or desktop PC running Microsoft Windows.
This was the same situation encountered in the previous article.

MS Windows already has a desktop.
As in the previous article, we will use the MS Windows desktop the as a "terminal" that can connect to remote systems.

However this time instead of installing Ubuntu Desktop, we will install Ubuntu Server.
Ubuntu Server will act as the remote system.

We would call Ubuntu Server "headless" because it does not include a GUI.
The headless server installation is more appropiate for teams of developers.

\subsection{Strategy}
Okay, so what's our strategy to setup a remote development enviroment?

We will:
\begin{itemize}
  \item Follow many of the steps found in the previous article.
  \item Install an Ubuntu Server distro rather than the Ubuntu Desktop distro.
  \item Make a few changes that are unique to the Server distro.
  \item Connect VSCode to the remote Ubuntu Server instance.
  \item Complete the enviroment setup.
\end{itemize}


\subsection{Ubuntu Server}
In the previous article, our guest OS was Ubuntu 22.04.5 LTS Desktop.
This time around our guest OS will be Ubuntu 22.04.5 LTS Server.

Let's download Ubuntu 22.04.5 LTS Server for AMD64 architecture from the Ubuntu project website.
Or download directly from here: https://ubuntu.com/download/server/thank-you?version=22.04.5&architecture=amd64&lts=true

In VirtualBox, or the hypervisor you are using, follow sections 1 thru 4 of the previous article.

Instead of naming the VM "alpha" we will name it "bravo".
Also, when asked how much space to dedicate to storage increase storage to 40Gb or more.
Why? 
Because we will be installing Docker, and our containers are hungry for storage.  

Boot Ubuntu Server in the VirtualBox VM then follow the setup prompts.
vwf tbd: provide info about prompts (choose all defaults?) 

\subsection{Initial Login}

\subsection{Network Setup}
Section 6 of the previous article provided instructions for setting up the network.
Those steps assumed a GUI since we were working with a Desktop version of Ubuntu.

This time around we are working with a headless server version of Ubuntu.
So, we will need to configure the network manually by editing text files.

Let's start by doing section 6.1 to setup a second virtual ethernet adapter as a bridged network adapter.

You will recall in Ubuntu Desktop the second virtual ethernet adapter was automatically setup to receive an IP address from your local DHCP server.
However, in Ubuntu Server we need to manually setup this second adapter with an IP address.

We'll manually setup the second adapter to receive a dynamic IP address from the local DHCP server.
We will do this to determine which network on the host (our laptop) to use for our bravo VM. 

Once we know which network to use we'll manually set a static IP address.
Setting a static IP address makes sense on a server because any clients need a reliable unchanging address to locate the server.

Let's start by discovering the virtual network adapters available to our VM.
At the commandline on the VM enter: 
\verbatim{begin} 
\$ ip a

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    ...
    ...
    ...
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:31:cd:75 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 metric 100 brd 10.0.2.255 scope global dynamic enp0s3
       valid_lft 79566sec preferred_lft 79566sec
    ...
    ...
    ...
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:c3:8e:b1 brd ff:ff:ff:ff:ff:ff
\verbatim{end} 

You should see output that looks similar to what is shown above.
We are interested in the two vitual adapters created by VirtualBox.
Above they start with the prefix "enp0s".

The vitual network adapter with ID=enp0s3 should have an IP4 address already set by VirtualBox.
This adapter was defined by the first adapter tab in VirtualBox.
In this case the address is 10.0.2.15 and the address was automatically assigned by DNS.
VirtualBox has it setup for NAT.
This adapter will be primarilly used for outbound connections to the internet from the VM, and inbound responses back to the VM.

You defined the second virtual network adapter with ID=enp0s8 on the second adapter tab in VirtualBox.
Remember you had defined this adapter in VirtualBox with Bridge Host configruation.  
You'll notice that adapter enp0s8 has no IP address assigned, yet.

\subsection{Netplan}

https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-18-04-bionic-beaver-linux

The network manager used by Ubuntu is called "Netplan".
Netplan is responsible for configuring any network adapters and getting an IP address assigned to them.

Netplan uses one or more yaml files to configure how it will setup adapters.

Open the file /etc/netplan/50-cloud-init.yaml in an editor:
\verbatim{begin}
\$ sudo vi /etc/netplan/50-cloud-init.yaml
\verbatim{end}

Edit the file to add configuration for adapter enp0s8.
Set it up to get its IP address from the DHCP server.
Save the file and quit the editor.
\verbatim{begin}
network:
    ethernets:
        enp0s3:
            dhcp4: true
        enp0s8:
            dhcp4: true
    version: 2
\verbatim{end}
sudo netplan apply

Now restart netplan to see the changes applied.
\verbatim{begin}
\$ sudo netplan apply
\$ ip a

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    ...
    ...
    ...
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:31:cd:75 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 metric 100 brd 10.0.2.255 scope global dynamic enp0s3
    ...
    ...
    ...
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:c3:8e:b1 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.117/24 metric 100 brd 10.0.0.255 scope global dynamic enp0s8
    ...
    ...
    ...
\verbatim{end}

Notice that adapter enp0s8 has an IP address assigned?
In the example above the IP address and subnet mask (CIDR block) is 10.0.0.117/24.
This tells us that the bravo VM is connected to the 10.0.0.X network via adapter enp0s8.

To test everything is working okay, ping address 10.0.0.117 from the Windows host on the laptop.

In Windows open a CMD shell session and enter:
\verbatim{begin}
C:\> ping 10.0.0.117
\verbatim{end}
You should see a reply from the bravo VM.
\verbatim{begin}


See /etc/netplan/99_config.yaml 
```
# This file is generated from information provided by the datasource.  Changes
# to it will not persist across an instance reboot.  To disable cloud-init's
# network configuration capabilities, write a file
# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
# network: {config: disabled}
network:
    ethernets:
        enp0s8:
            dhcp4: true
    version: 2
```


\subsection{Cloud Init}
Cloud init assumes Ubuntu Server will be running on a cloud platform.
It wants to setup the server's network to align with a cloud hosting enviroment.

We are not interested in running on a cloud platform, so we will manually setup the network.
To manually setup the network, we need to disable Cloud Init's network setup.

To disable Cloud Init's network setup, let's create a file at /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg containing the following line:
"network: {config: disabled}"

Better yet, run the following script at the command line:
```
echo "network: {config: disabled}" | sudo tee /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg > /dev/null
```

Ok, so what do we want to accomplish?
Let's assume we want to write Golang code for some project.

\begin{itemize}
  \item We will need a container setup to build/run our Golang program.
  \item We will need Docker/Podman installed on a remote Linux machine, to run the container.
  \item We will also need a client to manage code in our source control repository.
  \item We will need an IDE installed on our Windows laptop, talking to the remote Linux machine.
\end{itemize}

Our development environment will roughly look like Figure \ref{fig:fig1}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
  \node (r1) at (0,0)  [draw, align=center, label={[align=center]above:Windows\\Laptop}, minimum height=2cm,minimum width=2cm] {VSCode};
  \node (r2) at (5,0)  [draw, align=center, label={[align=center]above:Ubuntu\\Remote VM}, minimum height=2cm,minimum width=2cm] {Docker\\+ Git};
  \node (r3) at (10,0) [draw, align=center, label={[align=center]above:Dev\\Container}, minimum height=2cm,minimum width=2cm] {Golang};
  \node (r4) at (2.5,-5) [draw, align=center, minimum height=2cm,minimum width=2cm] {Git\\Repo};
  \node (r5) at (7.5,-5) [draw, align=center, minimum height=2cm,minimum width=2cm] {Container\\Repo};
  \draw[arrows={-Latex[length=6pt]}] (r1.east) -- (r2.west);
  \draw[arrows={-Latex[length=6pt]}] (r2.east) -- (r3.west);
  \draw[arrows={-Latex[length=6pt]}] (r2.south) -- (r4.north);
  \draw[arrows={-Latex[length=6pt]}] (r2.south) -- (r5.north);
\end{tikzpicture}
\caption{The Development Environment}
\label{fig:fig1}
\end{figure}


\subsection{Remote Dev Machine}

For this exercise, many of the technology choices will have already been made for us.
For example, our Windows 11 laptop is a given.

Other technology choices are open-ended.
The biggest choice we need to make is related to the remote development machine.
\begin{itemize}
  \item Which Linux distribution will we run?
  \item Will the machine be physical or virtual?
  \item What hardware are we running on?
\end{itemize}

If you have a remote physical machine that you can dedicate to running a Linux distribution, you are indeed lucky.
In most cases you will be interested in running a Linux distribution as a Virtual Machine inside a hypervisor.

Fortunately, there are many hypervisors available.
WSL, HyperV, vSphere, ESXi, ProxMox, VirtualBox: are some of the hypervisors you could use to run the Linux instance in a VM.
Many can be installed either on a networked server or locally on your laptop.
Which you choose depends upon budget, licensing and compute hardware.

Another popular solution is to run the Linux instance in a Cloud VM service.
For example AWS EC2 or Google Compute Engine are popular choices.

For my environment I will be installing Oracle VirtualBox hypervisor on my laptop.
Yes, the Linux instance can run in a VirtualBox hosted VM on the same Windows laptop where my IDE runs.
From the IDE's point of view, the Linux instance will appear to be on a remote network machine.
The IDE doesn't care if the remote machine lives in an EC2 instance or in my laptop's hypervisor 

\subsection{Linux Distribution}

The best place to start searching for a Linux distribution is DistroWatch\footnote{https://distrowatch.com}.
There you will find hundreds of Linux (and BSD) operating system distributions.

Linux distributions fall into two main families that differ by package manager and available packages.
Each has its pros and cons.
The RHEL/Fedora family uses the YUM package manager.
The Debian/Ubuntu family uses the APT package manager.

RHEL/Fedora has packages to install Podman and Buildah.
Podman increases security by enforcing rootless containers.

Debian/Ubuntu has packages to install Docker.
Docker is easier to work with since much existing tooling had been developed for it.
Sharing project files with developer containers is also easier in Docker.

For my development environment I will choose an Ubuntu\footnote{https://ubuntu.com/} Desktop distribution since I want the ease of working with Docker.

\subsection{Source Control}

Git is the de facto standard for modern source control.
Choosing Git is a no-brainer since I will be using a repository in GitHub to keep my source code.

\subsection{IDE}

Installing VSCode on my laptop is a matter of convenience.
Better IDEs probably exist, but I am familiar with VSCode.

VSCode has the advantage of developer container support.
It also has extensions that integrate remote SSH connections.

During routine usage VSCode acts almost like a thin-client terminal. 
Once VSCode is setup, developing code in a dev container on a remote machine appears similar to developing code on your local laptop.
This makes for a nice developer experience, to the point where one forgets where the code and compiler actually lives.

\subsection{Password Manager}

As you develop complex systems, you will accumulate (and forget) multiple passwords.
It is helpful to secure your account logins and passwords in a single place.

Several systems are available to keep your passwords handy and safe.
I recommended you install one of the following password managers: Bitwarden, 1Password and KeePassXC; on your PC.

\subsection{Laptop}

VirtualBox hypervisor will be running on the same laptop where VSCode will be installed.
For performance reasons it is worth noting the laptop configuration.
Knowing the laptop configuration helps when setting expectations and making comparisons to other hardware environments.

\begin{verbatim}
Device Specifications
---------------------
Manufacturer: Lenovo
Model: IdeaPad Slim 5 16IRU9
Processor: Intel(R) Core(TM) 7 150U   1.80 GHz
Installed RAM: 16.0 GB (15.7 GB usable)
Product ID: 00342-22290-21080-AAOEM
System type: 64-bit operating system, x64-based processor
Pen and touch: No pen or touch input is available for this display


Windows Specifications
----------------------
Edition: Windows 11 Home
Version: 24H2
Installed on: 2/14/2025
OS build: 26100.3775
Experience: Windows Feature Experience Pack 1000.26100.66.0
\end{verbatim}

\subsection{Environment Summary}

After much consideration, the development below was selected.
By no means is this an optimal solution.
You can swap in/other components of this environment to suit your development scenario.

\begin{itemize}
  \item Host OS: Windows 11 Home Edition
  \item Password Manager: KeePassXC 2.7.9
  \item Hypervisor: Oracle VirtualBox Version 7.1.6 r167084 (Qt6.5.3)
  \item IDE: Visual Studio Code 1.100.2 (user setup)
  \item Guest OS: Ubuntu 22.04.5 LTS Desktop
  \item Container runtime: Docker 28.8.1, build 4eba377
  \item Source code repository: GitHub
  \item Container image repository: DockerHub, Microsoft Artifact Registry
  \item Golang container: mcr.microsoft.com/devcontainers/go:1-1.23-bookworm
  \item Golang version: go1.23.8 linux/amd64
\end{itemize}

